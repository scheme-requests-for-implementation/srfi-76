<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>SRFI 76: R6RS Records</title>
</head>
<body>

<H1>Title</H1>

R6RS Records

<H1>Authors</H1>

Will Clinger, R. Kent Dybvig, Michael Sperber, Anton van Straaten

<H1>Status</H1>
This SRFI is currently in ``draft'' status.  For an explanation of
each status that a SRFI can hold, see 
<A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.  You can
access the discussion via <A HREF="mail-archive/maillist.html">the
archive of the mailing list</A>.

<UL>
<LI>Received: 2005-09-01
<LI>Draft: 2005-09-12
</UL>

<h1>Note</h1><p>This SRFI is being submitted by a member of the Scheme Language Editor's Committee as part of the Scheme standardization process.  The purpose of such ``R6RS SRFIs'' is to inform the Scheme community of features and design ideas under consideration by the editors and to allow the community to give the editors some direct feedback that will be considered during the design process.</p><p>At the end of the discussion period, this SRFI will be withdrawn. When the R6RS specification is finalized, the SRFI may be revised to conform to the R6RS specification and then resubmitted with the intent to finalize it.  This procedure aims to avoid the situation where this SRFI is inconsistent with R6RS.  An inconsistency between R6RS and this SRFI could confuse some users.  Moreover it could pose implementation problems for R6RS compliant Scheme systems that aim to support this SRFI.  Note that departures from the SRFI specification by the Scheme Language Editor's Committee may occur due to other design constraints, such as design consistency with other features that are not under discussion as SRFIs. </p><h1>Abstract</h1><p>This SRFI describes abstractions for creating new data types representing records - data structures with named fields.  This SRFI comes in four parts:</p><ul><li>a procedural layer for creating and manipulating record types and record
         instances</li><li>an explicit-naming syntactic layer for defining the various entities associated with a record type - constructor, predicate, field accessors, mutators, etc. - at once</li><li>an implicit-naming syntactic layer built on top of explicit-naming syntactic layer, which chooses the names for the various products based on the names of the record type and fields</li><li>a set of reflection procedures</li></ul><h1>Rationale</h1><p>The procedural layer allows dynamic construction of new record types and associated procedures for creating and manipulating records, which is particularly useful when writing interpreters that construct host-compatible record types.  It may also serve as a target for expansion of the syntactic layers.</p><p>The explicit-naming syntactic layer provides a basic syntactic interface whereby a single record definition serves as a shorthand for the definition of several record creation and manipulation routines: a constructor, a predicate, accessors, and mutators. As the name suggests, the explicit-naming syntactic layer requires the programmer to name each of these products explicitly. The explicit-naming syntactic layer is similar to <a href="http://srfi.schemers.org/srfi-9/">SRFI 9: Defining Record Types</a>, but adds several features, including single inheritance and non-generative record types.</p><p>The implicit-naming syntactic layer extends the explicit-naming syntactic layer by allowing the names for constructor, predicate, accessors, and mutators to be determined automatically from the name of the record and names of the fields.  This establishes a standard naming convention and allows record-type definitions to be more succinct, with the downside that the product definitions cannot easily be located via a simple search for the product name.  The programmer may override some or all of the default names by specifying them explicitly as in the explicit-naming syntactic layer.</p><p>The syntax of both syntactic layers is designed to obviate separate constructor procedures that shuffle arguments, provide default values for fields, and/or perform initialization actions on the created instance, such as registering it in some manner.</p><p>The syntax of both syntactic layers is also designed to allow future extensions by using clauses introduced by keywords.</p><p>The two layers are designed to be fully compatible; the implicit-naming layer is simply a conservative extension of the explicit-naming layer.  The goal is to make both explicit-naming and implicit-naming definitions reasonably natural while allowing a seamless transition between explicit and implicit naming.</p><p>The reflection procedures allow programs to obtain from a record instance a descriptor for the type and from there obtain access to the fields of the record instance.  This allows the creation of portable printers and inspectors.  A program may prevent access to a record's type and thereby protect the information stored in the record from the reflection mechanism by declaring the type <i>opaque</i>.</p><p>Fresh record types may be generated at different times---for example, when a record-type-defining form is expanded, or when it is evaluated.  The available choices all have different advantages and trade-offs.  These typically come into play when a record-type-defining form may be evaluated multiple times, for example, as part of interactive operation of the Scheme system, or as a body form of an abstraction.  The SRFI leaves the default generativity largely unspecified to allow different implementations, but also provides for non-generativity, which guarantees that the evaluation of identical record-type-defining forms yields compatible record types.</p><h1>Issues</h1><ul><li>The name <code>define-type</code> is used for both the implicit-naming and explicit-naming syntactic interfaces. It is unclear whether both names should in fact be the same. With different names it would be easier to identify when only the explicit-naming interface is being used; presumably, a module system would also make this possible.</li><li><p>Compared to some other record-defining forms that have been proposed and implemented, the syntax is comparatively verbose.  For instance, PLT Scheme has a <code>define-struct</code> form that allows record-type definitions as short as this:</p><pre>(define-struct point (x y))
</pre><p>The <a href="#design-rationale">Design Rationale section</a> explains why.</p><p>It would be possible to introduce abbreviations into the syntax. In the <code>fields</code> clause, a single identifier might serve as a shorthand for a <code>mutable</code> field clause:</p><pre>(define-type point (x y) (fields x y))
</pre><p>Even more radically, a default <code>fields</code> clause could be provided, with the constructor formals serving as implicit field names and initializers:</p><pre>(define-type point (x y))
</pre><p>Allowing such abbreviations would make some record definitions more concise but may also discourage programmers from specifying valuable field mutability information and taking advantage of nontrivial field initializers.  In any case, it is trivial to define forms like <code>define-struct</code> on top of this proposal.</p></li><li><p>Similarly, one might allow plain symbols to be used as field specifiers in the <var>fields</var> argument to <code>make-record-type-descriptor</code>, defaulting to mutability or immutability.</p></li><li><p>Should syntactic record-type definitions default to creating opaque or non-opaque record types?</p></li><li><p>The specification of <code>make-record-type-descriptor</code> has this:</p><blockquote>If <var>parent</var> is not <code>#f</code>, and <var>uid</var> is not <code>#f</code>, and the parent is generative  (i.e. its uid is <code>#f</code>), an error is signalled.</blockquote><p>However, the semantics would be perfectly clear even in the error case described above.  Should this restriction be lifted, if only for reasons of simplicity?</p></li><li><p>The specification of <code>eq?</code> on records allows certain kinds of unboxing optimizations, at the cost of leaving its behavior on records unspecified.  Should instead the following be required to hold for immutable records as well?</p><pre>(let ((r (construct ...)))
  (eq? r r))                ==&gt; #t
</pre></li><li><p>The behavior of <code>equal?</code> on records is one of several possibilities. See the <a href="http://www.lisp.org/HyperSpec/Issues/iss143-writeup.html">Issue EQUAL-STRUCTURE Writeup</a> in the Common Lisp HyperSpec on why any behavior of <code>equal?</code> on records is wrong for some purposes.</p></li><li><p>There is no way to use a record-type descriptor created by a call to <code>make-record-type-descriptor</code> as a parent type in a <code>define-type</code> form.  Should this be rectified, for example by another <code>define-type</code> clause named <code>parent-rtd</code>?</p></li><li><p>The semantics of generativity for the syntactic record-type-definition forms is presently unspecified.  Should this be tightened, and, if so, to what kind of generativity?</p></li></ul><p>We invite members of the Scheme community to express their opinions on these issues.</p><h1>Specification</h1><h2>Procedural layer</h2><dl><dt><code>(make-record-type-descriptor </code><var>name</var> <var>parent</var> <var>uid</var> <var>sealed?</var> <var>opaque?</var> <var>fields</var><code>)</code></dt><dd><p>This returns a <i>record-type descriptor</i>, or <i>rtd</i>.  The rtd represents a record type distinct from all built in types and other record types.  The rtd and the data type it represents are new except possibly if <var>uid</var> is provided (see below).</p><p>The <var>name</var> argument must be a symbol naming the record type; it is purely for informational purposes, and may be used for printing by the underlying Scheme system.</p><p>The <var>parent</var> argument is either <code>#f</code> or an rtd.  If it is an rtd, the returned record type, <i>t</i>, <i>extends</i> the record type <i>p</i> represented by <var>parent</var>.  Each record of type <i>t</i> is also a record of type <i>p</i>, and all operations applicable to a record of type <i>p</i> are also applicable to a record of type <i>t</i>, except for reflection operations if <i>t</i> is opaque but <i>p</i> is not.  An error is signalled if <var>parent</var> is sealed (see below).</p><p>The extension relationship is transitive in the sense that a type extends its parent's parent, if any, and so on. </p><p>The <var>uid</var> argument is either <code>#f</code> or a symbol. If it is a symbol, the created record type is <i>non-generative</i>, i.e. there may be only one record type with that uid in the entire system (in the sense of <code>eqv?</code>).  When <code>make-record-type-descriptor</code> is called repeatedly with the same <var>uid</var> argument (in the sense of <code>eq?</code>), the <var>parent</var> argument must be the same in the sense of <code>eqv?</code> (more on this below), and the <var>uid</var>, <var>sealed?</var>, <var>opaque?</var>, and <var>fields</var> arguments must be the same in the sense of <code>equal?</code>.  In this case, the same record-type descriptor (in the sense of <code>eqv?</code>) is returned every time.  If a call with the same uid differs in any argument, an error is signalled.  If <var>uid</var> is <code>#f</code>, or if no record type with the given uid has been created before, <code>make-record-type-descriptor</code> returns a fresh record-type descriptor representing a new type disjoint from all other types.</p><blockquote><i>Note: </i>Users are strongly strongly encouraged to use symbol names constructed using the <a href="http://www.ietf.org/rfc/rfc4122">UUID namespace</a> (for example, using the record-type name as a prefix) for the <var>uid</var> argument.</blockquote><p>If <var>parent</var> is not <code>#f</code>, and <var>uid</var> is not <code>#f</code>, and the parent is generative  (i.e. its uid is <code>#f</code>), an error is signalled.  In other words, the parent of a non-generative rtd must be non-generative itself.</p><p>The <var>sealed?</var> flag is a boolean.  If true, the returned record type is <i>sealed</i>, i.e., it cannot be extended.</p><p>The <var>opaque?</var> flag is a boolean.  If true, the returned record type is <i>opaque</i>.  This means that calls to <code>record?</code> will return <code>#f</code> and <code>record-type-descriptor</code> (see "Reflection" below) will signal an error. The record type is also opaque if an opaque parent is supplied. If <var>opaque?</var> is false and an opaque parent is not supplied, the record is not opaque.</p><p>The <var>fields</var> argument must be a list of <var>field specifiers</var>. Each <var>field specifier</var> must be a list of the form <code>(mutable </code><var>name</var><code>)</code>, or a list  of the form <code>(immutable </code><var>name</var><code>)</code>. The specified fields are added to the parent fields, if any, to determine the complete set of fields of the returned record type. Each <var>name</var> must be a symbol and names the corresponding field of the record type; the names need not be distinct. A field with tag <code>mutable</code> may be modified, whereas an attempt to obtain a mutator for a field with tag <code>immutable</code> will signal an error.</p><p>Where field order is relevant, e.g., for record construction and field access, the fields are considered to be ordered as specified, with parent fields first (and grandparent fields before that, and so on).  Although field access using indices uses the field order specified here, no particular order is required for the actual representation of a record instance, however.</p><p>A record type whose complete set of fields are all immutable is called <i>immutable</i> itself.  Conversely, a record type is called <i>mutable</i> if there is at least one mutable field in its complete set of fields.</p><p>A generative record-type descriptor created by a call to <code>make-record-type-descriptor</code> is not <code>eqv?</code> to any record-type descriptor (generative or non-generative) created by another call to <code>make-record-type-descriptor</code>.  A generative record-type descriptor is only <code>eqv?</code> to itself, i.e. <code>(eqv? rtd1 rtd2)</code> iff <code>(eq? rtd1 rtd2)</code>.  Moreover:</p><pre>(let ((rtd (make-record-type-descriptor ...)))
  (eqv? rtd rtd))                ==&gt; #t
</pre><p>Note that this does <em>not</em> imply the following:</p><pre>(let ((rtd (make-record-type-descriptor ...)))
  (eq? rtd rtd))                 ==&gt; #t
</pre><p>Also, two non-generative record-type descriptors are <code>eqv?</code> if they were successfully created by calls to <code>make-record-type-descriptor</code> with the same <var>uid</var> arguments.</p></dd><dt><code>(record-type-descriptor? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is a record-type descriptor, <code>#f</code> otherwise.</p></dd><dt><code>(record-constructor </code><var>rtd</var><code>)</code></dt><dd><p>Returns a procedure that returns a new instance of the record type represented by <var>rtd</var>. The procedure accepts one argument per field, in order, with parent fields first (and grandparent fields before that, and so on).</p><p>If <var>rtd</var> describes an opaque record type, then the values created by such a constructor are not considered by the reflection procedures to be records; see the specification of <code>record?</code> below.</p><p>A record from an immutable record type is called <i>immutable</i>; conversely, a record from an mutable record type is called <i>mutable</i>.</p><p>Two records created by such a constructor are equal according to <code>equal?</code> iff they are <code>eqv?</code>, provided their record type was not used to implement any of the types explicitly mentioned in the definition of <code>equal?</code>.</p><p>If <code>construct</code> is bound to a constructor returned by <code>record-constructor</code>, the following holds:</p><pre>(let ((r (construct ...)))
  (eqv? r r))                ==&gt; #t
</pre><p>For mutable records, but not necessarily for immutable ones, the following holds:</p><pre>(let ((r (construct ...)))
  (eq? r r))                 ==&gt; #t
</pre></dd><dt><code>(record-predicate </code><var>rtd</var><code>)</code></dt><dd><p>Returns a procedure that, given an object <var>obj</var>, returns <code>#t</code> iff <var>obj</var> is a record of the type represented by <var>rtd</var>.</p></dd><dt><code>(record-accessor </code><var>rtd</var> <var>field-id</var><code>)</code></dt><dd><p>Given a record-type descriptor <var>rtd</var> and a <var>field-id</var> argument that specifies one of the fields of <var>rtd</var>, <code>record-accessor</code> returns a one-argument procedure that, given a record of the type represented by <var>rtd</var>, returns the value of the selected field of that record.</p><p>It is an error if the accessor procedure is given something other than a record of the type represented by <var>rtd</var>. Note that it is an error even if the procedure's argument is of a parent type from which the selected field was inherited.</p><p>The <var>field-id</var> argument may be a symbol or an exact non-negative integer. If it is a symbol <var>s</var>, the field named <var>s</var> is selected. If more than one field has the given name, the field selected is the first field with that name in <var>rtd</var>, or, if there is no such field in <var>rtd</var>, the first field with that name in its parent, and so on.  If <var>field-id</var> is an exact non-negative integer <var>i</var>, the field at the 0-based index <var>i</var> is selected, where the fields are ordered as described under <code>make-record-type-descriptor</code> above.</p></dd><dt><code>(record-mutator </code><var>rtd</var> <var>field-id</var><code>)</code></dt><dd><p>Given a record-type descriptor <var>rtd</var> and a <var>field-id</var> argument that specifies one of the mutable fields of <var>rtd</var>, <code>record-accessor</code> returns a two-argument procedure that, given a record <var>r</var> of the type represented by <var>rtd</var> and an object <var>obj</var>, stores <var>obj</var> within the field of <var>r</var> specified by <var>field-id</var>. The <var>field-id</var> argument is as in <code>record-accessor</code>. If <code>record-mutator</code> is called on an immutable field, an error is signalled.</p></dd></dl><h2>Explicit-Naming Syntactic Layer</h2><p>The record-type-defining form <code>define-type</code> is a
        definition and can appear anywhere any other &lt;definition&gt; can appear.</p><dl><dt><code>(define-type </code>&lt;name-spec&gt; &lt;formals&gt; &lt;record clause&gt; *<code>)</code> (syntax)</dt><dd><p>A <code>define-type</code> form defines a new record type along with associated constructor, predicate, field accessors and field mutators.</p><p>The &lt;name-spec&gt; specifies the names of the record type, constructor, and predicate.  It must take the following form.</p><p><code>(</code>&lt;record name&gt; &lt;constructor name&gt; &lt;predicate name&gt;<code>)</code></p><p>&lt;Record name&gt;, &lt;constructor name&gt;, and &lt;predicate name&gt; must all be identifiers.</p><p>&lt;Record name&gt; is bound by this definition to a compile-time or run-time description of the record type for use as parent name in record definitions that extend this definition.  It may also be used as a handle to gain access to the underlying record-type descriptor (see <code>type-descriptor</code> below).</p><p>&lt;Constructor name&gt; is bound by this definition to a construction procedure. The construction procedure accepts the number(s) of arguments implied by &lt;formals&gt; and creates a new record instance of the defined type with the fields initialized as described below.</p><p>&lt;Predicate name&gt; is bound by this definition to a predicate for the defined record type.</p><p>&lt;Formals&gt; must be a formal argument list as in R5RS. The formals are visible as described below within the field &lt;init expression&gt;s, parent &lt;constructor argument&gt;s, and <code>init!</code> &lt;expression&gt;s.</p><p>Each &lt;record clause&gt; must take one of the following forms; it is an error if multiple &lt;record clause&gt;s of the same kind appear in a <code>define-type</code> form.</p><dl><dt><code>(fields </code>&lt;field-spec&gt; *<code>)</code></dt><dd><p>where each &lt;field-spec&gt; has one of the following forms</p><dl><dt><code>(</code>&lt;field name&gt;<code> (</code> &lt;accessor name&gt; <code>)</code> &lt;init expression&gt;?<code>)</code></dt><dt><code>(</code>&lt;field name&gt;<code> (</code> &lt;accessor name&gt; &lt;mutator name&gt; <code>)</code> &lt;init expression&gt;?<code>)</code></dt></dl><p>&lt;Field name&gt;, &lt;accessor name&gt;, and &lt;mutator name&gt; must all be identifiers; &lt;init expression&gt;, if present, must be an expression. The first form declares an immutable field called &lt;field name&gt;, with the corresponding accessor named &lt;acccessor name&gt;. The second form declares a mutable field called &lt;field name&gt;, with the corresponding accessor named &lt;acccessor name&gt;, and with the corresponding mutator named &lt;mutator name&gt;. In either form, &lt;init expression&gt; specifies the initial value of the field when it is created by the constructor. If &lt;init expression&gt; is absent, it defaults to 
	   &lt;field name&gt;.</p></dd><dt><code>(parent </code>&lt;parent name&gt;   &lt;constructor argument&gt; *<code>)</code></dt><dd><p>This specifies that the record type is to have parent type &lt;parent name&gt;, where &lt;parent name&gt; is the &lt;record name&gt; of a record type previously defined using <code>define-type</code>. The absence of a <code>parent</code> clause implies a record type with no parent type.</p><p>Each &lt;constructor argument&gt; must be an expression; the values of these expressions become the values of the parent's formals in the constructor.</p></dd><dt><code>(sealed)</code></dt><dd><p>If this option is specified, the defined record type is sealed, i.e., cannot be extended.  If no <code>sealed</code> option is present, the defined record type is not sealed.</p></dd><dt><code>(opaque)</code></dt><dd><p>If this option is specified, it means that the record type is opaque.  It is also opaque if an opaque parent is specified. If the <code>opaque</code> option is not present and an opaque parent is not specified, the record type is not opaque.</p></dd><dt><code>(nongenerative </code>&lt;uid&gt;<code>)</code></dt><dd><p>This specifies that the record type be nongenerative with uid &lt;uid&gt;, which must be an &lt;identifier&gt;. The absence of a <code>nongenerative</code> clause implies that the defined type is generative.  In the latter case, a new type may be generated once for each evaluation of the record definition or once for all evaluations of the record definition, but the type is guaranteed to be distinct even for verbatim copies of the same record definition appearing in different parts of a program.</p></dd><dt><code>(init! </code><code>(</code> &lt;identifier&gt; <code>)</code> &lt;expression&gt; *<code>)</code></dt><dd><p>When this clause is specified, the defined constructor arranges to evaluate the specified expressions in the scope of a binding for &lt;identifier&gt; to the new record instance, before the instance is returned from the constructor. Parent init expressions, if any, are evaluated before child init expressions.  The values of the expressions are ignored.</p></dd></dl><p>Note that all bindings created by this form (for the record type, the constructor, the predicate, the accessors, and the mutators) must have names that are pairwise distinct.</p><p>If the <code>define-type</code> form has a <code>nongenerative</code> clause, a subsequent evaluation of an identical <code>define-type</code> form will reuse the previously created rtd, and the procedures created will behave identically to the previously created ones.  If the implied arguments to <code>make-record-type-descriptor</code> are the same as with a previously evaluated <code>define-type</code> form are the same, the rtd is also reused, and bindings will be created or modified according to the more recent form. If the implied arguments to <code>make-record-type-descriptor</code> are not the same, an error is signalled.</p></dd><dt><code>(type-descriptor </code>&lt;record name&gt;<code>)</code> (syntax)</dt><dd><p>This evaluates to the record-type descriptor representing the type specified by &lt;record-name&gt;.</p></dd></dl><h2>Implicit-Naming Syntactic Layer</h2><p>The <code>define-type</code> form of the implicit-naming syntactic layer is  a conservative extension of the <code>define-type</code> form of the explicit-naming layer: a <code>define-type</code> form that conforms to the syntax of the explicit-naming layer also conforms to the syntax of the implicit-naming layer, and any definition in the implicit-naming layer can be understood by its translation into the explicit-naming layer.</p><p>This means that an record type defined by the <code>define-type</code> form of either layer can be used by the other.</p><p>The implicit-naming syntactic layer extends the explicit-naming layer in two ways.  First, &lt;name-spec&gt; may be a single identifier representing just the record name. In this case, the constructor name is generated by prefixing the record name with <code>make-</code>, and the predicate name is generated by adding a question mark (<code>?</code>) to the end of the record name. For example, if the record name is <code>frob</code> then the constructor name is <code>make-frob</code> and the predicate name is <code>frob?</code>.</p><p>Second, the syntax of &lt;field-spec&gt; is extended to allow the accessor and mutator names to be omitted.  That is, &lt;field-spec&gt; can take one of the following forms as well as the forms described in the preceding section.</p><dl><dt><code>(</code>&lt;field name&gt; <code>immutable</code> &lt;init expression&gt;?<code>)</code></dt><dt><code>(</code>&lt;field name&gt; <code>mutable</code> &lt;init expression&gt;?<code>)</code></dt></dl><p>If &lt;field-spec&gt; takes one of these forms, then the accessor name is generated by appending the record name and field name with a hyphen separator, and the mutator name (for a mutable field) is generated by adding a <code>-set!</code> suffix to the accessor name. For example, if the record name is <code>frob</code> and the field name is <code>widget</code>, the accessor name is <code>frob-widget</code> and the mutator name is <code>frob-widget-set!</code>.</p><p>Any definition that takes advantage of implicit naming can be rewritten trivially to a definition that conforms to the syntax of the implicit-naming layer merely by specifing the names explicitly. For example, the implicit-naming layer record definition:</p><pre>(define-type frob (n)
  (fields (widget mutable (make-widget n))))
</pre><p>is equivalent to the following explicit-naming layer record definition.</p><pre>(define-type (frob make-frob frob?) (n)
  (fields (widget (frob-widget frob-widget-set!) (make-widget n))))
</pre><p>With the explicit-naming layer, one can choose to specify just some of the names explicitly; for example, the following overrides the choice of accessor and mutator names for the <code>widget</code> field.</p><pre>(define-type frob (n)
  (fields (widget (getwid setwid!) (make-widget n))))
</pre><h2>Reflection</h2><p>A set of procedures are provided for reflecting on records and their record-type descriptors. These procedures are designed to allow the writing of portable printers and inspectors. </p><p>Note that these procedures treat records of opaque record types as if they were not record.  On the other hand, the reflection procedures that operate on record-type descriptors themselves are not affected by opacity.  In other words, opacity controls whether a program can obtain an rtd from an instance.  If the program has access to the rtd through other means, it can reflect on it.</p><dl><dt><code>(record? </code><var>obj</var><code>)</code></dt><dd><p>Returns <code>#t</code> if <var>obj</var> is a record, and its record type is not opaque. Returns <code>#f</code> otherwise.</p></dd><dt><code>(record-type-descriptor </code><var>rec</var><code>)</code></dt><dd><p>Returns the rtd representing the type of <var>rec</var> if the type is not opaque. The rtd of the most precise type is returned; that is, the type <var>t</var> such that <var>rec</var> is of type <var>t</var> but not of any type that extends <var>t</var>. If the type is opaque, <code>record-type-descriptor</code> signals an error.</p></dd><dt><code>(record-type-name </code><var>rtd</var><code>)</code></dt><dd><p>Returns the name of the record-type descriptor <var>rtd</var>.</p></dd><dt><code>(record-type-parent </code><var>rtd</var><code>)</code></dt><dd><p>Returns the parent of the record-type descriptor <var>rtd</var>, or <code>#f</code> if it has none.</p></dd><dt><code>(record-type-uid </code><var>rtd</var><code>)</code></dt><dd><p>Returns the uid of the record-type descriptor <var>rtd</var>, or <code>#f</code> if it has none.  (An implementation may assign a generated uid to a record type even if the type is generative, so the return of a uid does not necessarily imply that the type is nongenerative.)</p></dd><dt><code>(record-type-generative? </code><var>rtd</var><code>)</code></dt><dd><p>Returns <code>#t</code> if <var>rtd</var> is generative, and <code>#f</code> if not.</p></dd><dt><code>(record-type-sealed? </code><var>rtd</var><code>)</code></dt><dd><p>Returns a boolean value indicating whether the record-type descriptor is sealed.</p></dd><dt><code>(record-type-opaque? </code><var>rtd</var><code>)</code></dt><dd><p>Returns a boolean value indicating whether the record-type descriptor is opaque.</p></dd><dt><code>(record-type-field-names </code><var>rtd</var><code>)</code></dt><dd><p>Returns a list of symbols naming the fields of the type represented by <var>rtd</var> (not including the fields of parent types) where the fields are ordered as described under <code>make-record-type-descriptor</code>.</p></dd><dt><code>(record-field-mutable? </code><var>rtd</var> <var>field-id</var><code>)</code></dt><dd><p>Returns a boolean value indicating whether the field specified by <var>field-id</var> of the type represented by <var>rtd</var> is mutable, where <var>field-id</var> is as in <code>record-accessor</code>.</p></dd></dl><h1><a name="design-rationale">Design Rationale</a></h1><h2>Field initialization and verbosity</h2><p>To define a record type with two mutable fields, this proposal requires at least:</p><pre>(define-type point (x y)
  (fields (x mutable)
          (y mutable)))
</pre><p>While this is arguably verbose, the proposed syntax generalizes gracefully beyond this trivial sort of record definition, as illustrated by the two record definitions below.</p><pre>(define-type hash-table (pred hasher size)
  (fields (pred immutable pred)
          (hasher immutable hasher)
          (data mutable (make-vector (nearest-prime size)))
          (count mutable 0)))

(define-type eq-hash-table (pred hasher size)
  (parent hash-table pred hasher size)
  (fields (gc-count mutable 0)))
</pre><p>The first defines a <code>hash-table</code> record with four fields: <code>pred</code>, <code>hasher</code>, <code>data</code>, and <code>count</code>.  Two of the fields, <code>pred</code> and <code>hasher</code>, are immutable and set to the values of the first two constructor arguments.  The <code>data</code> field is initialized to a vector whose size is a function of the third constructor argument.  The <code>count</code> field is initialized to zero.</p><p>The second extends the <code>hash-table</code> record to form an <code>eq-hash-table</code> record with an additional <code>gc-count</code> field, used in systems whose collectors move objects to determine if a collection has occurred since the last rehash.  The child record does not initialize the parent fields directly but rather defers to the initialization code in the parent record definition by passing along the constructor arguments.</p><p>If the custom field initialization were omitted, it would still be possible to perform custom initialization by writing a separate constructor procedure, which would wrap a record type's actual constructor.  However, this creates the need for an extra procedure name which is not part of the record type's definition.  This means that extensions which deal with the record type's definition (such extensions to support keyword arguments, etc.) don't have access to the record type's actual constructor.</p><h2><code>init!</code> clause</h2><p>When constructing records, custom initialization code is commonly required, because the initial field values often do not have a one-to-one correspondence to the constructor arguments.  There may also be a need to perform other construction-time initialization, such as calling a procedure to "register" the new record.</p><p>Internally, record construction involves an initialization step, and the <code>init!</code> clause provides a hook into this step, in order to support custom initialization.</p><p>If this feature were omitted, many record-type definitions would require a separate constructor procedure, with the same consequences as explained above in the section on field initialization.</p><p>The <code>init!</code> clause addresses this common requirement by allowing arbitrary operations on the new record instance, before it is returned from the constructor.  This eliminates the need to define a constructor wrapper procedure, and means that the record type's defined constructor can always be the actual constructor used by clients.</p><h1>Examples</h1><h2>Procedural layer</h2><pre>(define point (make-record-type-descriptor 'point #f #f #f #f '((mutable x) (mutable y))))
(define make-point (record-constructor point))
(define point? (record-predicate point))
(define point-x (record-accessor point 'x))
(define point-y (record-accessor point 'y))
(define point-x-set! (record-mutator point 'x))
(define point-y-set! (record-mutator point 'y))

(define p1 (make-point 1 2))
(point? p1) ; =&gt; #t
(point-x p1) ; =&gt; 1
(point-y p1) ; =&gt; 2
(point-x-set! p1 5)
(point-x p1) ; =&gt; 5

(define point2 (make-record-type-descriptor 'point2 point #f #f #f '((mutable x) (mutable y))))
(define make-point2 (record-constructor point2))
(define point2? (record-predicate point2))
(define point2-x (record-accessor point2 0))
(define point2-y (record-accessor point2 1))
(define point2-xx (record-accessor point2 2))
(define point2-yy (record-accessor point2 3))

(define p2 (make-point2 1 2 3 4))
(point? p2) ; =&gt; #t
(point2-x p2) ; =&gt; 1
(point2-y p2) ; =&gt; 2
(point2-xx p2) ; =&gt; 3
(point2-yy p2) ; =&gt; 4
(point-x p2) ; =&gt; 1
(point2-x p1) ; error
</pre><h2>Explicit-naming syntactic layer</h2><pre>(define-type (pare kons pare?) (x y)
  (fields (x (kar set-kar!) x)
          (y (kdr) y)))

(pare? (kons 1 2)) ; =&gt; #t
(pare? (cons 1 2)) ; =&gt; #f
(kar (kons 1 2)) ; =&gt; 1
(kdr (kons 1 2)) ; =&gt; 2
(let ((k (kons 1 2)))
  (set-kar! k 3)
  (kar k)) ; =&gt; 3

(define-type (point make-point point?) (x y)
  (fields (x (point-x) x)
          (y (point-y set-point-y!) y))
  (nongenerative point-4893d957-e00b-11d9-817f-00111175eb9e))

(define-type (cpoint make-cpoint cpoint?) (x y c)
  (parent point x y)
  (fields (rgb (cpoint-rgb cpoint-rgb-set!) (color-&gt;rgb c))))

(define (color-&gt;rgb c)
  (cons 'rgb c))

(define p1 (make-cpoint 3 4 'red))
(point? p1) ; =&gt; #t
(cpoint-rgb p1) ; =&gt; (rgb . red)
</pre><h2>Implicit-naming syntactic layer</h2><pre>(define-type (point make-point point?) (x y)
  (fields (x immutable x)
          (y mutable y))
  (nongenerative point-4893d957-e00b-11d9-817f-00111175eb9e))

(define *the-cpoint* #f)

(define-type cpoint (x y c)
  (parent point x y)
  (fields (rgb mutable (color-&gt;rgb c)))
  (init! (p) (set! *the-cpoint* p)))

(define cpoint-i1 (make-cpoint 1 2 'red))
(cpoint? cpoint-i1) ; =&gt; #t
(cpoint-rgb cpoint-i1) ; =&gt; (rgb . red)
(cpoint-rgb-set! cpoint-i1 '(rgb . blue))
(cpoint-rgb cpoint-i1) ; =&gt; (rgb . blue)
(eq? *the-cpoint* cpoint-i1) ; =&gt; #t
</pre><h1>Reference implementation</h1><p>The <a href="implementation/records-reference.tar.gz">reference implementation </a>makes use of <a href="http://srfi.schemers.org/srfi-9/">SRFI 9</a> (Defining Record Types), <a href="http://srfi.schemers.org/srfi-23/">SRFI 23</a> (Error reporting mechanism), and <a href="http://srfi.schemers.org/srfi-26/">SRFI 26</a> (Notation for Specializing Parameters without Currying) for the procedural layer and the explicit-naming syntactic layer. The implementation of the explicit-naming syntactic layer also assumes <code>letrec*</code> semantics (as specified by the upcoming R6RS) for internal definitions to support internal record-type definitions. The explicit-naming syntactic layer cannot be implemented using <code>syntax-rules</code> alone.  Two implementations, one for Scheme 48 using explicit renaming, and one for PLT Scheme using <code>syntax-case</code> are provided.</p><h1>References</h1><p>Over the years, many records proposal have been advanced.  This section lists only the ones that were a direct influence to this proposal.</p><p>The procedural layer of this SRFI is essentially an extension of a proposal that was considered by the R*RS authors about 15 years ago, and was supported at that time by a vote of approximately 28 to 2.  On 1 September 1989, Pavel Curtis posted the proposal to rrrs-authors.  Norman Adams reposted Pavel's proposal on 5 February 1992. Kent Dybvig presented an extended version of Pavel's proposal along with a syntactic interface, both developed in collaboration with Bill Rozas, at the 1998 Scheme Worshop. Pavel's proposal was also a starting point for Chez Scheme's procedural interface. The mechanism for defining and using constructor arguments in the syntactic interface is similar to the syntax used by the Scheme Widget Library for class definitions. Single inheritance was added to Larceny in 1998 and Chez Scheme in 1999, but it is likely that other implementations had inheritance before then.</p><ul><li><a href="http://zurich.csail.mit.edu/pipermail/rrrs-authors/1992-May/001303.html">Pavel Curtis's 1989 proposal</a></li><li><a href="http://srfi.schemers.org/srfi-9/">SRFI 9: Defining Record Types</a> by Richard A. Kelsey</li><li>The Records section in the <a href="http://www.scheme.com/csug/">Chez Scheme User's Guide</a> by R. Kent Dybvig</li><li><a href="http://www.cs.indiana.edu/chezscheme/swlman/">SWL Reference Manual</a> by Oscar Waddell</li><li>The (undocumented) <code>define-record</code> form of <a href="http://www.iro.umontreal.ca/~gambit/">Gambit-C 4.0beta</a>.</li></ul><h1>Acknowledgements</h1><p>We are grateful to Donovan Kolbly who did extensive pre-draft editing.</p><p>This SRFI was written in consultation with the other R6RS editors: Marc Feeley, Matthew Flatt, and Manuel Serrano.</p><H1>Copyright</H1>
Copyright (C) Will Clinger, R. Kent Dybvig, Michael Sperber, Anton van Straaten (2005). All Rights Reserved. 
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Donovan Kolbly</a></address>
</body></html>
